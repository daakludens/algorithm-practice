# 폰켓몬
얼핏 보면 조건이 굉장히 많아 보이지만 단순하게 생각해보면 매우 쉽다.

목적은 최대한 다양한 폰켓몬을 데려가는 거고, 주어진 조건은 전체 폰켓몬 숫자의 반만 데려갈 수 있는 거다.
그러니까 전체의 반을 max라고 봤을 때, 폰켓몬 종류가 max보다 많다면 max만큼의 폰켓몬을 데려가면 된다.
그러나 폰켓몬의 종류가 max에 못 미친다면, 폰켓몬 종류 가지가 최대 max가 된다.

코드로는 제시된 전체 폰켓몬의 반을 max 값으로 둔다. 
그 다음 전체 중 중복된 포켓몬을 제외한 수를 max와 비교해, max보다 크다면 max 값을, max보다 작거나 같으면 중복 제외한 폰켓몬 수를 반환하면 된다.

<br>

## 풀이
```
import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.Arrays;

class Solution {
    public int solution(int[] nums) {
        int max = nums.length/2;
        
        TreeSet<Integer> set = Arrays.stream(nums).boxed().collect(Collectors.toCollection(TreeSet::new));
        
        if (set.size() > max) { return max; } 
        else { return set.size(); }
    }
}
```

<br>

## 문제
