# 3진법 뒤집기
처음 보는 3진법에 어리둥절 했지만, 그 원리만 제대로 파악하면 쉬운 문제다.
이 문제에서 중요한 건 3진법에서 10진법으로, 그리고 10진법에서 3진법으로 전환하는 방법을 알면 된다.

3진법은 정말 처음 접하는 방식이라... 구글로 공부를 해야 했는데 의외로 3진법을 설명한 곳이 없다.
그래서 개인적으로 배운 걸 까먹지 않기 위해 여기 좀 자세히 적어본다.

<br>

## 3진법이란?
3진법은 0, 1, 2으로만 숫자를 표현하는 방식이다.

<br>

### 10진법 -> 3진법
우선 10진법에서 3진법의 전환 과정은 10진법의 숫자를 계속해서 3으로 나누면 된다.
다만 3으로 나눌 때마다 몫과 나머지를 잘 챙겨야 한다.
왜냐면 `몫은 3으로 나누는 대상`이 되고 `나머지는 3진법 표현에 사용`된다.
3으로 나누는 행위는 몫이 0이 되는 순간 끝나고, 순서대로 나온 `나머지 숫자들을 반대로 뒤집어야 한다.`

42를 예를 들어 해본다.
```
// 첫번째 나누기
42 / 3 = 14 ...0   // 몫 = 14, 나머지 = 0
```

```
// 두번째 나누기
14 / 3 = 4 ... 2   // 몫 = 4, 나머지 = 2
```

```
// 세번째 나누기
4 / 3 = 1 ... 1   // 몫 = 1, 나머지 = 1
```

```
// 네번째 나누기
1 / 3 = 0 ... 1   // 몫 = 0, 나머지 = 1
```

나머지 0211를 모아 놓고 역순으로 놓은 `1120`이 3진법으로 표현한 42이다.

<br>

### 3진법 -> 10진법
그러면 1120을 다시 42로 바꿔본다.
여기서 1자리 숫자부터 위로 올라가면서 3승을 해주면 된다.

```
// 1자리
// 0 * (3 ^ 0) = 0

// 10자리
// 2 * (3 ^ 1) = 6

// 100자리
// 1 * (3 ^ 2) = 9

// 1000자리
// 1 * (3 ^ 3) = 27

// 결과
// 0 + 6 + 9 + 27 = 42
```

<br>

## 풀이 전 브레인스토밍
알기 전에 3진법으로 만든 숫자의 순서를 뒤집어서 다시 계산해야 한다는 조건을 읽으면 '아... 그 유명한 Stack / Queue를 써야 하는 건가?' 라고 생각했다.
하지만 3진법을 이해하고 문제를 다시 읽으면 우리를 배려(?)해줬다는 게 여실히 느껴진다.
10진법에서 3진법으로 변환할 때 몫의 순서를 뒤바꿔 줘야 하는데, 이 문제에서는 바로 변환한 그 순서 그대로 다시 10진법으로 바꿔주면 되기에 더 간단하다.

10진법으로 다시 변환할 땐 뒤에서부터 3승을 곱해야 하기에 3진법 표현의 숫자 길이에서 3승 단위를 빼주는 형식으로 진행했다.

또한 고려할 점은 Math의 pow() 메서드를 사용할 때 반환 값은 무조건 double 자료형이다.
그러기에 int로 변환해주는 작업이 필요하다.

<br>

## 풀이
```
import java.util.List;
import java.util.ArrayList;
import java.lang.Math;

class Solution {
    public int solution(int n) {
        List<Integer> terniaryList = new ArrayList<Integer>();
        int answer = 0;
        
        while (n != 0) {
            int remainder = n % 3;
            terniaryList.add(remainder);
            n = n / 3;
        }
        
        for (int i = 0; i < terniaryList.size(); i++) {
            int value = terniaryList.get(terniaryList.size() - i - 1) * (int)(Math.pow(3, i));
            answer += value;
        }
        
        return answer;
    }
}
```
