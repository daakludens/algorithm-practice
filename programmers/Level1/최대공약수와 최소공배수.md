# 최대공약수와 최소공배수
쉽게 생각하고 도전했다가 예상 외로 고민을 요구한 문제였다.

오히려 이 문제로 이참에 새로운 알고리즘 방식과 사고 방식을 배울 수 있어 좋은 기회였다.
이번 건 좀 길게 썼다.

<br>

## 첫번째 풀이(이거 쉬운거 아니야?? - 착각편)
```
class Solution {
    public int[] solution(int n, int m) {
        int[] answer = new int[2];
        int b = 0;
        int s = 0;
        
        if (n > m)  { b = n; s = m; }
        else { b = m; s = n; }
        
        if (b % s == 0) {
            answer[0] = s;
            answer[1] = b;
        } else {
            answer[0] = 1;
            answer[1] = b*s;
        }
        
        return answer;
    }
}
```

<br>

주어진 테스트 케이스 2개를 토대로 이러면 되지 않을까? 해서 만든 첫 작품이다.
물론 테스트 케이스는 넘겼지만 최종 실행에서 정답률 20%도 넘기지 못하고 실패했다.
아, 뭔가 잘못했구나 싶어서 단어에 대해 더 자세히 알아보고 알고리즘을 찾아봤다.

<br>

## 최대공약수와 최소공배수란???
위의 두 개념은 수학의 `정수론`에서 소개된다.
정수론이란 정수만을 다루는 학문으로 정수만이 가지는 약수와 배수, 몫과 나머지에 대해 다룬다고 한다.
컴퓨터의 도입으로 학문의 유용성이 대두되고 있다고 하며, 특히 `암호화`에서 잘 쓰인다고 한다.

![image](https://user-images.githubusercontent.com/71559880/138583702-93f3488d-81c5-4b28-a3cd-01ad1e1f7568.png)                   
출처 : [정수론](https://dimenchoi.tistory.com/46)

두개의 수가 주어졌을 때 각 수를 소인수분해를 한 다음,         
중복되는 모든 소인수의 곱을 최대공약수라고 하고, 전체 소인수의 곱을 최소공배수라고 한다.

또한 최소공배수와 최대공약수를 곱한 값은 두 수를 곱한 값과 같다.
최소 공배수와 최대 공약수를 곱하면 두 수의 공통된 소인수를 두 번 곱하고 나머지 값을 한 번 곱하는 거다. 
두 수를 곱하는 것도 결과적으론 공통 소인수를 두 번 곱하고 나머지 값을 곱하기에 같아진다.

이제 두 수의 최대공약수와 최소공배수의 계산 방법을 알아봐야 한다.
일반적으로 소인수분해를 하면 되지만 컴퓨터로 할 때는 `유클리드 호제법`으로 더 효율적으로 알아낼 수 있다.

<br>

## 유클리드 호제법
`유클리드 호제법`은 두 수의 최대 공약수를 구하는 방법으로 한 번 이해하면 매우 쉽다.        
a와 b라는 정수가 있고, 두 수의 최대 공약수를 구하는 게 목표라 가정한다.
그럼 a / b = d ... r 이며, d는 몫, r은 나머지를 의미한다.                 
처음 나누기를 실행하고 다음으로 b값을 나누는 첫째값으로 두고 나머지였던 r을 나누는 두번째 값으로 둔다.                    
즉, `a / b = d ... r => b / r`을 하며, 몫이 0이 될 때까지 반복하면 된다. 그때의 b값이 최대공약수가 된다.                  

최소공배수는 구하기 쉽다. 위에 최소공배수와 최대공약수를 곱한 값이 두 값의 곱이라고 했다.
그렇다면 `최소공배수 * 최대공약수 = a * b`이므로 `최소공배수 = (a * b) / 최대공약수`가 된다.

<br>

## 다시 풀이
```
class Solution {
    public int[] solution(int n, int m) {
        int[] answer = new int[2];
        int a = 0;
        int b = 0;
        int r = 0;
        
        // 크기 비교해서 분류
        if (n > m)  { a = n; b = m; }
        else { a = m; b = n; }
        
        // 유클리드 호제법
        while (b != 0) {
            r = a % b;
            a = b;
            b = r;
        }
        
        // 최대공약수와 최소공배수 입력
        answer[0] = a;
        answer[1] = (n * m) / a;
        
        return answer;
    }
}
```
